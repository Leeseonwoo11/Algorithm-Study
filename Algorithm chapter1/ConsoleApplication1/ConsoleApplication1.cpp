// ConsoleApplication1.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

//  잡스러운연습 코드들
using namespace std;

int get_Euclid_Alogrithm1(int u, int v) // 유클리드 알고리즘 함수
{
	int t;
	if (u < 0 || v < 0)
	{
		cout << "음수가 포함되어 있습니다." << endl;
		return 0;
	}

	while (u)
	{
		if (u < v)
		{
			t = u;
			u = v;
			v = t;
		}
		u = u - v;
	}
	return v;
}

int get_Euclid_Alogrithm2(int u, int v)
{
	int t;

	while (v)
	{
		t = u % v;
		u = v;
		v = t;
	}
	return u;
}

bool isprime1(int a)
{
	for (int i = 2; i < a; i++)
	{
		if (a%i == 0)
		{
			return false;
		}
	}
	return true;
}

bool isprime2(int a)
{
	int t = (int)std::sqrt(a);
	for (int i = 2; i <= t; i++)
	{
		if (a%i == 0)
		{
			return false;
		}
	}
	return true;
}

//지정된 수 까지 소수를 출력하는 함수
void primeprint1(int n)
{
	for (int i = 1; i <= n; i++)
	{
		if (isprime1(i))
		{
			cout << i << " ";
		}
	}
	cout << endl;
}
void primeprint2(int n)
{
	for (int i = 1; i <= n; i++)
	{
		if (isprime2(i))
		{
			cout << i << " ";
		}
	}
	cout << endl;
}

int main()
{
    std::cout << "this is a laptop ! \n";
	std::cout << " this is a desktop ! \n";

	// 쉬프트 연산으로 정수를 나누거나 곱할 수 있다. 32page
	int a = 20;
	int b = 16;
	
	a = a << 2; // a에 2에2승(4) 곱하기 쉬프트 << 2
	cout << a << endl;

	b = b >> 3; // b에 2에3승(8) 나누기 쉬프트 >>2;
	cout << b << endl;

	// 알고리즘은 결코 어느것이 낫다고 할 수 없다 상황에 따라서 달라진다.

	/* 1.2알고리즘의 분석
	 알고리즘의 분석은 객관적인 비교 분석을 경험적 혹은 수학적으로 한 것이다.
	 
	 경험적 분석
	 경험적 분석은 알고리즘을 구현을 한 뒤 실행시키고 실행시간을 비교해 보면서 분석하는것
	 수학적인 지식이 필요없다는 장점이 있다.
	 수학적 분석
	 프로그래밍으로 구현함이 없이 단지 알고리즘 자체만을 가지고 수학적 분석을 하는 것
	 수학적 분서은 소프트웨어 공학의 주요한 부분이 될 정도로 어렵고 깊은 분야
	 수학적 분석은 알고리즘을 프로그래밍하는 과정이 없기 때문에 프로그래밍하는 과정에서 같은 알고리즘이라도 프로그래머의 능력에 따라
	 나타날 수 있는 성능의 편차를 없앨 수 있다는 장점이 있다.

	 알고리즘의 분석의 단계
	 첫번째 알고리즘을 판달할 수 있는 입력자료를 결정하는 것
	 두번째 알고리즘을 구성하는 동작들을 추상적 기본적인 동작들로 분해하여 동작 수행시간을 게산해 보는것
	 세번째 수학적 알고리즘 분석을 행하는것. 최악의 경우는 수학적으로 게산하기 비교적 쉬움 평균적인 경우는 계산하기 어려움

	 알고리즘의 유형
	 알고리즘 분석의 결과는 입력되는 자료의 수 N에 대하여 수행시간을 함수 관계로 표현한 것

	 1
	 입력자료의 수에 간게없이 일정한 실행시간을 갖는 알고리즘

	 logN 
	 만약 입력자료의 수에 따라 실행시간이 logN의 관계를 만족한다면 N이 증가함에 따라 실행시간이 조금씩 늘어난다.

	 N
	 입력자료의 수에 따라 선형적으로 실행시간이 걸리는 경우

	 NlogN
	 이 유형은 커다란 문제를 독립적인 작은 문젤 쪼개어 각각에 대해 독립적으로 해결하고 나중에 다시 그것들을 하나로 모으는 경우에 나타난다.
	 N이 두배로 늘어나면 실행시간은 두배보다 약간 더 많이 늘어난다.

	 N**2(N의 2승)
	 이 유형은 이중 루프 내에서 입력자료를 처리하는 경우에 나타난다. N값이 큰 값이 실행되면 실행시간은 감당할 수 없을 정도로 커지게 된다.
	 이러한 알고리즘은 많은 양의 입력자료에 대해서는 부적절하다.

	 N**3
	 이 유형도 앞의 유형과 비슷 3중루프내에서 처리하는 경우에 나타난다.

	 2**N
	 입력자료의 수가 늘어남에 따라 급격히 실행시간이 늘어난다. 이 유형은 흔하지않지만 가끔씩 나온다.


	 시간 소요량과 공간 소요량
	 시간소요량
	 알고리즘이 얼마만큼의 시간을 필요로 하는가
	 공간소요량
	 알고리즘이 얼마만큼의 공간을 필요로 하는가
	 */

	//유클리드의 알고리즘 최대공약수 찾기
	// 두 수가 공통적으로 나누어 지는 수로 나누어 내려가다가 더이상 공통적으로 나눠지는 수가 없다면 나누어 내려간 수들을 모두 곱하면 최대공약수가 나온다. 
	cout <<"최대 공약수는 "<< (get_Euclid_Alogrithm1(5, 7))<<" 입니다."<<endl;
	cout << endl;

	// 유클리드 알고리즘의 개선
	//빼기연산을 나머지 연산으로 바꿀 수가 있다. 이렇게 되면 연산량이 줄어든다.
	cout << "최대 공약수는 " << (get_Euclid_Alogrithm2(5, 7)) << " 입니다." << endl;
	cout << endl;

	// 소수인지 아닌지 구별하는 알고리즘
	cout << "소수감별 : " << (isprime1(59) ? "소수" : "소수아님") << endl;
	cout << endl;

	// 소수감별 알고리즘을 이용해서 지정된 수 까지 소수를 출력하는 함수
	primeprint1(200); //1 부터 200 까지 수 중에서 소수 출력함
	cout << endl;
	// 소수감별 알고리즘 개선 : 해당하는 수 까지 1씩 더해가며 나머지를 계산하는 것 보다 해당하는 수의 제곱근까지 하면 계산량이 줄어든다.
	cout << "소수감별 : " << (isprime2(59) ? "소수" : "소수아님") << endl;
	cout << endl;
	// 제곱근을 이용해서 개선된 소수감별 알고리즘을 이용해서 지정된 수 까지 소수를 출력하는 함수
	primeprint2(59);
	cout << endl;

	//최적화 기법
	/*최적화를 위한 방법의 첫번째 좋은 알고리즘을 선택
	 함수를 사용하라
	 실수형을 사용하지 말라
	 반복문 내를 간단하게 하라
	 재귀 호출 사용하지 마라
	 최적화 단계는 항상 프로그램 작성시 최후의 단계여야 한다.
	*/
	
}


